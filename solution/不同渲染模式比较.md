## SSG + CSR 结合方式

### 1. 基础模式：静态外壳 + 动态数据

```jsx
// pages/dashboard.js
export async function getStaticProps() {
  // 构建时获取基础数据
  const initialData = await fetchInitialData();
  
  return {
    props: { initialData },
    revalidate: 3600 // ISR: 每小时重新生成
  };
}

export default function Dashboard({ initialData }) {
  // 客户端实时获取最新数据
  const { data } = useSWR('/api/live-data', fetcher, {
    fallbackData: initialData, // 先显示静态数据
    refreshInterval: 5000      // 每5秒更新
  });
  
  return (
    <div>
      <h1>{initialData.staticTitle}</h1>
      <LiveData data={data} /> {/* 动态更新 */}
    </div>
  );
}
```

**工作流程：**
1. CDN 返回预渲染的 HTML（带 `initialData`）
2. 用户立即看到内容（无白屏）
3. JS 加载后，SWR 用静态数据初始化
4. 后台发起请求获取最新数据
5. 页面静默更新，用户无感知

### 2. 部分静态 + 部分动态

```jsx
export async function getStaticProps() {
  const staticContent = await fetchStaticContent(); // 不常变的内容
  
  return {
    props: { staticContent }
  };
}

export default function Page({ staticContent }) {
  const [userSpecificData, setUserSpecificData] = useState(null);
  
  useEffect(() => {
    // 客户端获取用户相关数据
    fetchUserData().then(setUserSpecificData);
  }, []);
  
  return (
    <div>
      {/* 静态部分：SEO 友好，立即显示 */}
      <article>
        <h1>{staticContent.title}</h1>
        <div>{staticContent.body}</div>
      </article>
      
      {/* 动态部分：个性化内容 */}
      {userSpecificData && (
        <aside>
          <h2>为你推荐</h2>
          <Recommendations data={userSpecificData} />
        </aside>
      )}
    </div>
  );
}
```

### 3. 使用 ISR 实现渐进式更新

```jsx
export async function getStaticProps() {
  const data = await fetchData();
  
  return {
    props: { data },
    revalidate: 60 // 60秒后重新生成
  };
}

export default function Page({ data }) {
  // 客户端立即更新最新数据
  const { data: liveData } = useSWR('/api/data', fetcher, {
    fallbackData: data
  });
  
  return <Content data={liveData} />;
}
```

**更新策略：**
- 首次访问：CDN 返回静态 HTML（可能是几分钟前的）
- JS 执行：客户端获取最新数据并更新
- 60秒后有新请求：Next.js 后台重新生成静态页面

## 实际场景示例

### 电商产品页

```jsx
export async function getStaticProps({ params }) {
  const product = await fetchProduct(params.id);
  
  return {
    props: { product },
    revalidate: 300 // 5分钟
  };
}

export default function ProductPage({ product }) {
  // 实时库存和价格
  const { data: liveInfo } = useSWR(
    `/api/products/${product.id}/live`,
    fetcher,
    { refreshInterval: 10000 }
  );
  
  return (
    <div>
      {/* 静态内容：商品描述、图片 */}
      <h1>{product.name}</h1>
      <img src={product.image} />
      <p>{product.description}</p>
      
      {/* 动态内容：价格、库存 */}
      <div>
        <Price amount={liveInfo?.price || product.price} />
        <Stock count={liveInfo?.stock || product.stock} />
      </div>
    </div>
  );
}
```

### 博客文章页

```jsx
export async function getStaticProps({ params }) {
  const post = await fetchPost(params.slug);
  
  return {
    props: { post },
    revalidate: 86400 // 24小时
  };
}

export default function PostPage({ post }) {
  // 实时评论数
  const { data: comments } = useSWR(
    `/api/posts/${post.id}/comments`,
    fetcher
  );
  
  // 实时点赞数
  const { data: likes, mutate } = useSWR(
    `/api/posts/${post.id}/likes`,
    fetcher
  );
  
  const handleLike = async () => {
    // 乐观更新
    mutate({ count: likes.count + 1 }, false);
    await fetch(`/api/posts/${post.id}/like`, { method: 'POST' });
    mutate();
  };
  
  return (
    <article>
      {/* 静态文章内容 */}
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
      
      {/* 动态互动部分 */}
      <button onClick={handleLike}>
        ❤️ {likes?.count || 0}
      </button>
      <Comments data={comments} />
    </article>
  );
}
```

## 其他方案对比

### 方案 1: Pure SSG（纯静态）
```jsx
// 完全不用客户端渲染
export async function getStaticProps() {
  const data = await fetchData();
  return { props: { data } };
}
```
**问题：** 数据可能过时，没有实时性

### 方案 2: SSR（服务端渲染）
```jsx
export async function getServerSideProps() {
  const data = await fetchData(); // 每次请求都获取
  return { props: { data } };
}
```
**优点：** 数据总是最新的
**缺点：** 
- 慢（每次都要服务器渲染）
- 不能 CDN 缓存
- 服务器压力大

### 方案 3: SSG + ISR（推荐）
```jsx
export async function getStaticProps() {
  const data = await fetchData();
  return {
    props: { data },
    revalidate: 60 // 后台重新生成
  };
}
```
**优点：** 快速 + 数据相对新鲜
**缺点：** 有延迟（最多 60 秒旧数据）

### 方案 4: SSG + CSR（最灵活，推荐）
```jsx
export async function getStaticProps() {
  const staticData = await fetchStaticData();
  return { props: { staticData } };
}

export default function Page({ staticData }) {
  const { data } = useSWR('/api/live', fetcher, {
    fallbackData: staticData
  });
  return <div>{data}</div>;
}
```
**优点：** 
- 首屏极快（CDN + 静态 HTML）
- 数据实时（客户端更新）
- 灵活控制更新策略
- SEO 友好

## 最佳实践建议

**分层策略：**
- **静态层**：布局、导航、不变的内容 → SSG
- **半静态层**：商品信息、文章内容 → SSG + ISR
- **动态层**：用户数据、实时数据 → CSR
- **高频动态层**：聊天、股价 → WebSocket/CSR

**更新频率指导：**
```javascript
// 几乎不变（文档、历史数据）
revalidate: false 或 86400 (24小时)

// 偶尔变化（博客、产品）
revalidate: 3600 (1小时) + CSR按需更新

// 经常变化（新闻、库存）
revalidate: 60 (1分钟) + CSR实时更新

// 高频变化（评论、点赞）
不用revalidate，纯CSR
```

所以答案是：**SSG + CSR 不仅可以结合，而且是最佳实践**。你既能享受 CDN 缓存的速度，又能通过客户端渲染保证数据的实时性。